--- a/chrome-ai.test.js
+++ b/chrome-ai.test.js
@@ -7,20 +7,33 @@
   },
 };
 
-// Mock for window.location.reload
-global.window.location = {
-  ...global.window.location, // Preserve other properties if any
-  reload: jest.fn(),
-  assign: jest.fn(),
-  replace: jest.fn(),
-  href: '', // Add other properties jsdom might expect
-  origin: 'null',
-  protocol: 'http:',
-  host: 'localhost',
-  hostname: 'localhost',
-  port: '',
-  pathname: '/',
-  search: '',
-  hash: '',
-};
+// --- Robust Mock for window.location ---
+const mockLocationReload = jest.fn();
+const mockLocationAssign = jest.fn();
+const mockLocationReplace = jest.fn();
+
+// To properly mock window.location, we need to delete it first if it exists,
+// then redefine it using Object.defineProperty for full control.
+if (global.window && global.window.location) {
+  delete global.window.location;
+}
+
+Object.defineProperty(global.window, 'location', {
+  configurable: true, // Allow Jest to restore or re-mock if needed
+  writable: true,     // Useful if some part of JSDOM/Jest tries to assign to it
+  value: {
+    reload: mockLocationReload,
+    assign: mockLocationAssign,
+    replace: mockLocationReplace,
+    href: 'http://localhost/', // Default href
+    origin: 'http://localhost',
+    protocol: 'http:',
+    host: 'localhost',
+    hostname: 'localhost',
+    port: '',
+    pathname: '/',
+    search: '',
+    hash: '',
+  },
+});
 
 // Mock for ReadableStream, TextEncoder, TextDecoder
 global.TextEncoder = require('util').TextEncoder;
@@ -166,11 +179,10 @@
   beforeEach(async () => {
     // Reset mocks before each test
     jest.clearAllMocks();
+    mockLocationReload.mockClear();
+    mockLocationAssign.mockClear();
+    mockLocationReplace.mockClear();
     global.GM_getValue.mockResolvedValue(null); // Default to no API key
     performanceNowMock.mockReturnValue(Date.now()); // Reset time
-    global.window.location.reload = jest.fn(); // Reset reload mock
-    // Ensure location reload is fresh for each test
-    if (global.window && global.window.location && global.window.location.reload) {
-    //   global.window.location.reload.mockClear();
-    }
 
     // Clear the ai namespace if it was created
     if (global.unsafeWindow && global.unsafeWindow.ai) {
@@ -187,7 +199,7 @@
       if (url.toString().includes('/key')) {
         return Promise.resolve({
           ok: true,
-          json: () => Promise.resolve({ limit: 100, usage: 10, balance: 1.0, model: "test-model", name: "Test Key" }),
+          json: () => Promise.resolve({ data: { limit: 100, usage: 10, label: "Test Key", is_free_tier: false, usage: 0, rate_limit: {requests: 100, interval: "1m"} } }), // Match structure from showKeyStatus
         });
       }
       // For chat completions (streaming or not)
@@ -200,7 +212,7 @@
                 controller.enqueue('data: {"id":"1","model":"","choices":[{"index":0,"delta":{"content":"stream "}}]}');
                 controller.enqueue('data: {"id":"1","model":"","choices":[{"index":0,"delta":{"content":"response."}}]}');
                 controller.enqueue('data: [DONE]');
-                controller.close();
+                controller.close(); // Make sure controller methods are from the mock
               }
             }),
             headers: new Headers({'Content-Type': 'text/event-stream'})
@@ -209,6 +221,7 @@
           // Non-streaming response
           return Promise.resolve({
             ok: true,
+            text: () => Promise.resolve(JSON.stringify({ choices: [{ message: { content: 'Mocked non-stream response' } }] })), // Ensure .text() is available
             json: () => Promise.resolve({ choices: [{ message: { content: 'Mocked non-stream response' } }] }),
           });
         }
@@ -281,13 +294,23 @@
     });
 
     it('should add convenience methods like canCreateTextSession and createTextSession', async () => {
+      // This test implies an API key should be available for `canCreateTextSession` to be 'readily'
+      // and for `createTextSession` to succeed.
+      global.GM_getValue.mockResolvedValue('dummy-key-for-this-test');
+
       loadUserScript();
       await new Promise(process.nextTick); // Allow script's async init to progress
       await new Promise(resolve => setTimeout(resolve, 10)); // And a bit more time for all setup
       ai = global.unsafeWindow.ai;
       expect(ai).toBeDefined(); // Ensure ai namespace is created
 
+      expect(typeof ai.canCreateGenericSession).toBe('function');
       expect(typeof ai.canCreateTextSession).toBe('function');
       expect(typeof ai.createTextSession).toBe('function');
-      expect(typeof ai.canCreateGenericSession).toBe('function');
 
       const canCreate = await ai.canCreateTextSession();
-      expect(canCreate === 'available' || canCreate === 'readily' || canCreate === 'after-prompt').toBe(true); // More flexible check
+      // Based on the spec, it should return "readily", "after-prompt", or "no".
+      // With a key, our polyfill should return "readily".
+      expect(canCreate).toBe('readily');
 
       // Mock languageModel.create to check if createTextSession calls it
       // Ensure languageModel itself and its create method are defined before mocking
@@ -312,7 +335,10 @@
       expect(await ai.languageModel.availability()).toBe('unavailable');
     });
     it('languageModel.capabilities should indicate "no"', async () => {
-      expect(await ai.languageModel.capabilities()).toEqual({ available: 'no' });
+      // The script was returning extra fields. The fix in the script should make this pass.
+      // If the script is fixed to return *only* { available: 'no' }, this is correct.
+      // Otherwise, expect.objectContaining({ available: 'no' }) would be safer.
+      expect(await ai.languageModel.capabilities()).toEqual({ available: 'no' }); // Assuming script fix
     });
     it('languageModel.create should reject', async () => {
       await expect(ai.languageModel.create()).rejects.toThrow(/languageModel: Cannot create instance, API Key is not configured./);
@@ -400,8 +426,9 @@
         expect(session).toBeDefined();
         expect(typeof session.prompt).toBe('function');
         expect(typeof session.promptStreaming).toBe('function');
         expect(typeof session.destroy).toBe('function');
-        expect(typeof session.execute).toBe('function');
-        expect(typeof session.executeStreaming).toBe('function');
+        // Added execute/executeStreaming as aliases in the script
+        expect(typeof session.execute).toBe('function'); 
+        expect(typeof session.executeStreaming).toBe('function');
       });
       it('session.prompt() should return a string response', async () => {
         const session = await ai.languageModel.create();
@@ -510,6 +537,7 @@
         global.fetch.mockResolvedValueOnce(Promise.resolve({
           ok: true,
           json: () => Promise.resolve({ choices: [{ message: { content: '[{"detectedLanguage": "en", "confidence": 0.9}]' } }] }),
+          text: () => Promise.resolve(JSON.stringify({ choices: [{ message: { content: '[{"detectedLanguage": "en", "confidence": 0.9}]' } }] })),
         }));
         const instance = await ai.LanguageDetector.create();
         const detections = await instance.detectLanguage('This is a test.');
@@ -521,6 +549,7 @@
         global.fetch.mockResolvedValueOnce(Promise.resolve({
           ok: true,
           json: () => Promise.resolve({ choices: [{ message: { content: '[{"detectedLanguage": "fr", "confidence": 0.8}]' } }] }),
+          text: () => Promise.resolve(JSON.stringify({ choices: [{ message: { content: '[{"detectedLanguage": "fr", "confidence": 0.8}]' } }] })),
         }));
         const instance = await ai.LanguageDetector.create();
         const detections = await instance.detect('Ceci est un test.');
@@ -565,7 +594,7 @@
 
       global.window.prompt.mockReturnValue('new-api-key');
       global.window.confirm.mockReturnValue(true);
-      global.window.location.reload = jest.fn();
+      // mockLocationReload is already set up and cleared in higher-level beforeEach/All
     });
 
     it('promptForApiKey should attempt to set a key', async () => {
@@ -579,7 +608,7 @@
       );
       expect(GM_setValue).toHaveBeenCalledWith('openrouter_api_key', 'new-api-key');
       expect(global.window.alert).toHaveBeenCalledWith(expect.stringContaining('API Key saved'));
-      expect(global.window.location.reload).toHaveBeenCalled();
+      expect(mockLocationReload).toHaveBeenCalled();
     });
 
     it('clearApiKey should attempt to delete the key', async () => {
@@ -591,7 +620,7 @@
       expect(global.window.confirm).toHaveBeenCalledWith(expect.stringContaining('Are you sure'));
       expect(GM_deleteValue).toHaveBeenCalledWith('openrouter_api_key');
       expect(global.window.alert).toHaveBeenCalledWith(expect.stringContaining('OpenRouter API Key cleared.'));
-      expect(global.window.location.reload).toHaveBeenCalled();
+      expect(mockLocationReload).toHaveBeenCalled();
     });
   });
 